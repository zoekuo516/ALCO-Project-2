# ALCO-Project-2
## Problem 1 - Euclidean algorithm
利用兩個數去做輾轉相除法，當其中有一個數是0的時候就會離開while迴圈，因為當其中有一個是0的時候就代表另一個數就是他們的最大公因數，然後while迴圈裡面就是在做輾轉相除法，先判斷哪個數比較大，然後再用大的值去%小的值，得出來的值不斷取代上一個值，直到有一個值是0。
## Problem 2 - Special sort
有兩個數n,m，n是有這個數列幾個數要做排序，m是被除數，所以n有幾個就要除m幾次，然後我先用一個odd的function取絕對值來防止餘數是負的，然後再利用sort函數裡面的cmp比較函數把題目給的條件寫進去，第一個if是n%m的餘數比較小的排前面比較大的排後面，所以是要用<這個符號，如果用>就是從大排到小，第二個if是如果n%m的餘數一樣的話就要把基數排前面偶數排後面，第三個if是我的值都是基數，把數字大的排前面小的排後面，最後return就是回傳是偶數的值，小的在前面大的在後面，main裡面就是先輸入n個大小的array，然後呼叫sort函式，做cmp function的排序再用一個for迴圈輸出。
## Problem 3 - 精靈群島的傳送門
在main裡面我有先用一個int map做出N*N的地圖來，然後把map陣列裡面清空，下面的for迴圈就是做輸入的動作，tempA跟tempB是存島的編號然後把它push back到vertex裡，然後把他的成本放到map的陣列中，之後就利用Prim’s algorithm來做，設兩個變數Vert_A是有哪些島還沒走過，Vert_B是已經走過哪些島，裡面的兩個for迴圈就是找出有哪個島跟哪個島的成本最少，然後把值先存到edge的temp裡，用sum把剛剛找出的成本累加，再把temp的值push_back到Ans，最後利用算幾不等式求出[ t*X + C(i,j)/t ] >= 2* [t * X*C(i,j)/t]^(1/2) = 2* [X*C(i,j)]^(1/2)算出t= [C(i,j)/X]^(1/2)也就是第一個要輸出的值，第二個輸出的值就是傳送門的數量，也就是剛剛上面所求出Ans的大小，最後是要輸出有哪幾個島是要建立傳送門的就把之前找出A跟B的值輸出。
## Problem 4 - Independent Set
我的main裡面是先把每個點跟每個點之間有相連的邊放到陣列中且呼叫edge_value將值設為1，然後max function就是把每一列中值為1的累加，累加後再用一個for迴圈去跑，把累加後最大的值輸出出來。
